<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Martin Sjogard">
<meta name="dcterms.date" content="2025-01-15">

<title>A Permutation-Based Approach for Determining the Number of Clusters in K-means Clustering – Martin Sjogard</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d7b13c2189a2074b64ee850e6083e072.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../custom.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Martin Sjogard</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-posts" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Posts</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-posts">    
        <li>
    <a class="dropdown-item" href="../../posts/power-analysis-lmm/index.html">
 <span class="dropdown-text">Power Analysis for LMMs</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../posts/fwer-correction-part1/index.html">
 <span class="dropdown-text">FWER Correction, background pt.&nbsp;1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../posts/fwer-correction-part2/index.html">
 <span class="dropdown-text">FWER Correction, background pt.&nbsp;2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../posts/kmeans-permutation/index.html">
 <span class="dropdown-text">Developing a novel cluster number determination for K-means clustering</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/martinsjogard/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:martinsjogard@gmail.com"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://scholar.google.com/citations?user=F59U3gEAAAAJ&amp;hl=en"> <i class="bi bi-mortarboard-fill" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../CV_Martin_Sjogard.pdf"> <i class="bi bi-file-text" role="img">
</i> 
<span class="menu-text">CV</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#motivation-and-intuition" id="toc-motivation-and-intuition" class="nav-link active" data-scroll-target="#motivation-and-intuition">Motivation and intuition</a></li>
  <li><a href="#intuitive-explanation-to-sort-my-own-thoughts" id="toc-intuitive-explanation-to-sort-my-own-thoughts" class="nav-link" data-scroll-target="#intuitive-explanation-to-sort-my-own-thoughts">Intuitive explanation to sort my own thoughts</a></li>
  <li><a href="#statistical-foundation" id="toc-statistical-foundation" class="nav-link" data-scroll-target="#statistical-foundation">Statistical foundation</a></li>
  <li><a href="#algorithm-description" id="toc-algorithm-description" class="nav-link" data-scroll-target="#algorithm-description">Algorithm description</a></li>
  <li><a href="#r-implementation" id="toc-r-implementation" class="nav-link" data-scroll-target="#r-implementation">R implementation</a></li>
  <li><a href="#comparison-and-discussion" id="toc-comparison-and-discussion" class="nav-link" data-scroll-target="#comparison-and-discussion">Comparison and Discussion</a>
  <ul class="collapse">
  <li><a href="#advantages-of-the-permutation-method" id="toc-advantages-of-the-permutation-method" class="nav-link" data-scroll-target="#advantages-of-the-permutation-method">Advantages of the permutation method:</a></li>
  <li><a href="#limitations" id="toc-limitations" class="nav-link" data-scroll-target="#limitations">Limitations</a></li>
  </ul></li>
  <li><a href="#example-results-on-real-data" id="toc-example-results-on-real-data" class="nav-link" data-scroll-target="#example-results-on-real-data">Example results on real data</a></li>
  <li><a href="#when-to-consider-this-method" id="toc-when-to-consider-this-method" class="nav-link" data-scroll-target="#when-to-consider-this-method">When to consider this method</a></li>
  <li><a href="#future" id="toc-future" class="nav-link" data-scroll-target="#future">Future</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">A Permutation-Based Approach for Determining the Number of Clusters in K-means Clustering</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Statistics</div>
    <div class="quarto-category">Neuroscience</div>
    <div class="quarto-category">R</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Martin Sjogard </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 15, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="motivation-and-intuition" class="level2">
<h2 class="anchored" data-anchor-id="motivation-and-intuition">Motivation and intuition</h2>
<p>I have been thinking about novel ways to estimate the number of clusters in K-means clustering for a few weeks. Of the available methods, many provide a heuristic or relative measure of cluster quality, but few give a firm statistical significance test for the presence of clusters. In this part, I will walk through a porposed approach – a Permutation-Based Permutation Test on within-cluster-sum-of-squares (WCSS) – to determine the number of clusters in a more hypothesis-driven manner. The core idea is to ask: “Is the reduction in within-cluster variance achieved by having K clusters significantly better than what would be expected by random chance?” If yes, then K clusters captures real structure; if not, adding that cluster may be fitting noise.</p>
<p>This method is inspired by permutation tests commonly used in statistical inference and by recent research that applies permutation strategies to clustering. I’ll leverage permutations to create a baseline for clustering performance under a null hypothesis of <em>no meaningful clusters</em>. I’ll start with the null hypothesis that the data have no intrinsic cluster structure (i.e., no or one cluster, depending on your view). I then measure how much WCSS improves increase K increases, and I compare that to how much improvement you could get on random shuffled data. When the improvement is no longer significant, I stop increasing K. This yields an estimated “optimal” K with a statistical justification (controlled false-alarm rate). This approach combines intuitive reasoning (clustering should significantly outperform random partitions) with rigorous testing.</p>
<p>I thought about this approach for about one week so far, so it may well be trash. Let’s see where I end up:</p>
</section>
<section id="intuitive-explanation-to-sort-my-own-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="intuitive-explanation-to-sort-my-own-thoughts">Intuitive explanation to sort my own thoughts</h2>
<p>Imagine you have a cloud of data points. Now suppose I randomly assign them into K clusters (just by chance, without regard to their positions). Even with random assignment, you’ll get some WCSS value – probably high (clusters won’t be tight) but not as high as one cluster because random assignment might by chance put some close points together. If you try different random assignments, you get a distribution of WCSS values that represent “what WCSS might look like if there were no real clusters, just random groupings.”</p>
<p>Now, if your actual K-means clustering on the real data yields a WCSS that is much lower than these random assignments, that suggests the data has genuine cluster structure (points are much closer to their cluster mates than random chance would allow). I can formalize this by a permutation test: shuffle the data (or equivalently, break any structure in data by permuting) and recompute clustering many times to see what random WCSS values I get. Then check where the actual WCSS lies in that distribution.</p>
<p>For a given K, the null hypothesis H0 is: “there is no clustering structure (points are i.i.d. with no clusters)”. If H0 were true, any grouping of that size K is essentially arbitrary. The alternative is <em>the data has an inherent K-cluster structure that produces a significantly lower WCSS than random groupings</em>.</p>
<p>I will find the largest K for which I can reject H0 (i.e., the clustering is significantly better than random). That K will be my chosen number of clusters. Intuitively, as K grows large, even random assignments can achieve low WCSS (because many clusters = each cluster has few points = trivially small within-cluster variance). So at some point, the real data’s advantage over random will diminish. I will want to stop at the point where adding another cluster no longer yields a statistically significant gain. This approach <em>reduces subjectivity by anchoring cluster decisions to a significance level</em> (like 0.05). It’s like saying “I’ll only increase K as long as each new cluster gives me a meaningful improvement beyond what noise could explain.”</p>
</section>
<section id="statistical-foundation" class="level2">
<h2 class="anchored" data-anchor-id="statistical-foundation">Statistical foundation</h2>
<p>I define <span class="math inline">\(W(K)\)</span> as the total within-cluster sum of squares for K clusters (computed by, say, K-means algorithm). Note <span class="math inline">\(W(1) \ge W(2) \ge \dots \ge W(n)\)</span> (monotonically decreases as K increases). I want to test for each K &gt; 1 whether the decrease from K-1 to K is significant.</p>
<p>One way to do this is consider <strong>the drop in WCSS</strong> when going from K-1 to K clusters: <span class="math inline">\(\Delta W_K = W(K-1) - W(K)\)</span>. This is the reduction in within-cluster variance by adding one more cluster. If data have K real clusters, I’d expect a big drop in WCSS up to K, then much smaller drops after (elbow effect). I can test:</p>
<ul>
<li><p>H0: Data has at most K-1 clusters (no meaningful K cluster structure). Under H0, adding the Kth cluster yields little improvement beyond random chance.</p></li>
<li><p>H1: Data has K clusters (the Kth cluster captures structure).</p></li>
</ul>
<p>I simulate H0 by permutation: a simple method is to randomly permute each feature independently among data points (this destroys any multivariate structure or clustering, while roughly preserving univariate distributions). Another is to randomly assign cluster labels to points (which is akin to random grouping). Permuting features is nice because it keeps the distribution of each coordinate but breaks correlations that define cluster separation</p>
<p>For each permutation <span class="math inline">\(b\)</span> (b = 1..B), I compute <span class="math inline">\(W^{(b)}(K)\)</span> using K-means on the permuted data. This gives a null distribution of WCSS for K clusters. I can compute <span class="math inline">\(\Delta W_K^{(b)} = W^{(b)}(K-1) - W^{(b)}(K)\)</span> for the permuted data as well. Now consider a test statistic. I could use the drop <span class="math inline">\(\Delta W_K\)</span> directly, or an F-like ratio. The Calinski-Harabasz index is essentially proportional to <span class="math inline">\(\frac{\Delta W_K/(K-1)}{W(K)/(,n-K,)}\)</span>, which looks like an F. But for simplicity, I can just use <span class="math inline">\(\Delta W_K\)</span> itself or <span class="math inline">\(W(K)\)</span> itself. A simple choice: use <span class="math inline">\(W(K)\)</span> as the test statistic (lower is better clustering). If the data truly has K clusters, <span class="math inline">\(W_{\text{real}}(K)\)</span> will be much lower than <span class="math inline">\(W^{(b)}(K)\)</span> from permuted data. So I can calculate a p-value:</p>
<p><span class="math display">\[
p_K = \Pr\left(W^{\text{perm}}(K) \leq W_{\text{real}}(K)\right)
\]</span></p>
<p>In practice, from B permutations,</p>
<p><span class="math display">\[
\hat{p}_K = \frac{1}{B} \sum_{b=1}^{B} \mathbb{I} \left\{ W^{(b)}(K) \leq W_{\text{real}}(K) \right\},
\]</span></p>
<p>i.e.&nbsp;the fraction of permuted trials where the permuted WCSS is as low or lower than the actual. If <span class="math inline">\(p_K\)</span> is very small, it means actual data’s clustering is much tighter than any random permutation achieved – evidence for K clusters.</p>
<p>However, using <span class="math inline">\(W(K)\)</span> directly can be problematic because <span class="math inline">\(W(K)\)</span> always decreases with K even for permuted data. Instead, focusing on the improvement from K-1 to K might be more informative. So alternatively, test whether <span class="math inline">\(\Delta W_K\)</span> is larger than expected under null. Formally:</p>
<p><span class="math display">\[
p_K = \Pr\left( \Delta W_K^{\text{perm}} \geq \Delta W_K^{\text{real}} \right)
\]</span></p>
<p>I want to see if the drop in WCSS by adding cluster K is bigger than what random data would typically give when adding one more cluster. The two approaches (testing <span class="math inline">\(W(K)\)</span> or testing <span class="math inline">\(\Delta W_K\)</span>) are related. Testing <span class="math inline">\(W(K)\)</span> directly asks if the clustering as a whole is unusual; testing <span class="math inline">\(\Delta W_K\)</span> focuses on the incremental benefit of the Kth cluster. The incremental approach might be better to decide when to stop adding clusters sequentially.</p>
<p><strong>Procedure outline</strong>: Start at K=1. Increase K one by one, and for each K do a permutation test: if significant (say p &lt; 0.05), reject H0 that no K-cluster structure, and continue; if not significant, stop – use K-1 as final clusters. This sequential testing needs a little care with multiple comparisons, but one can control overall type I error by a small alpha at each step or use a stepwise stopping rule (similar to how forward selection in stats stops when no significant improvement). This method essentially ensures I only add clusters while they provide a statistically significant improvement. Permutation approaches have been used in hierarchical clustering to decide where to cut a dendrogram, and multi-aspect tests combine multiple indices for a global test. Here I focus on WCSS since it’s natural for K-means.</p>
</section>
<section id="algorithm-description" class="level2">
<h2 class="anchored" data-anchor-id="algorithm-description">Algorithm description</h2>
<p>Putting it all together, here’s the algorithm for the permutation test method:</p>
<ul>
<li><p><strong>1. Input:</strong> Data matrix X (n x d), maximum clusters K_max to consider, number of permutations B, significance level <span class="math inline">\(\alpha\)</span> (say 0.05).</p></li>
<li><p><strong>2. For K = 2 to K_max:</strong> Cluster the real data into K-1 and K clusters (e.g.&nbsp;using K-means with multiple starts for stability). Compute <span class="math inline">\(W_{\text{real}}(K-1)\)</span> and <span class="math inline">\(W_{\text{real}}(K)\)</span>, and the drop <span class="math inline">\(\Delta W_{\text{real}} = W_{\text{real}}(K-1) - W_{\text{real}}(K)\)</span>. Then, for b = 1 to B: Permute the data (shuffle each feature’s values among samples, independently for each feature). Cluster permuted data into K-1 and K. Compute <span class="math inline">\(W^{(b)}(K-1), W^{(b)}(K)\)</span> and <span class="math inline">\(\Delta W^{(b)}\)</span>. Then, compute p-value for improvement: <span class="math inline">\(p_K = \frac{1}{B}\sum_{b=1}^B I{\Delta W^{(b)} \ge \Delta W_{\text{real}}}\)</span>. (This is a one-sided test; if I wanted to test against too low improvement, I could do opposite inequality, but here large drop means good cluster). Finally, if <span class="math inline">\(p_K &lt; \alpha\)</span>, conclude that adding the Kth cluster gave significant improvement (so likely at least K clusters in data) and continue to next K. If <span class="math inline">\(p_K \ge \alpha\)</span>, stop and set optimal clusters = K-1.</p></li>
<li><p><strong>3. Failure:</strong> If no stop occurred up to K_max, either choose K_max or consider increasing K_max (or using other criteria to decide beyond).</p></li>
</ul>
<p>I could alternatively compute <span class="math inline">\(p_K\)</span> for <span class="math inline">\(W(K)\)</span> being significantly lower than permuted, but the sequential drop test aligns with the idea of testing each additional cluster.</p>
<p><strong>Significance threshold</strong>: If I use <span class="math inline">\(\alpha=0.05\)</span> at each step, the overall type I error is not exactly 0.05 (multiple testing), but since I stop when a test fails, it’s a form of sequential testing. Some simulation could calibrate this, but in practice this is heuristic. If you’re worried, a Bonferroni or so could be applied (e.g.&nbsp;use <span class="math inline">\(\alpha/K_{\max}\)</span> each time to be conservative). This method is somewhat akin to how you might do forward feature selection with significance tests, stopping when no new feature adds value.</p>
</section>
<section id="r-implementation" class="level2">
<h2 class="anchored" data-anchor-id="r-implementation">R implementation</h2>
<p>Below is an R implementation outline for this permutation test approach. I will implement a function <code>permute_k_test()</code> that returns the recommended K.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>permute_k_test <span class="ot">&lt;-</span> <span class="cf">function</span>(data, <span class="at">K.max =</span> <span class="dv">10</span>, <span class="at">B =</span> <span class="dv">10000</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  optK <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  km1 <span class="ot">&lt;-</span> <span class="fu">kmeans</span>(data, <span class="at">centers =</span> <span class="dv">1</span>, <span class="at">nstart =</span> <span class="dv">10</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  prevW <span class="ot">&lt;-</span> km1<span class="sc">$</span>tot.withinss</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (K <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>K.max) {</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    kmK <span class="ot">&lt;-</span> <span class="fu">kmeans</span>(data, <span class="at">centers =</span> K, <span class="at">nstart =</span> <span class="dv">10</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    W_K <span class="ot">&lt;-</span> kmK<span class="sc">$</span>tot.withinss</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    delta_real <span class="ot">&lt;-</span> prevW <span class="sc">-</span> W_K</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    delta_perm <span class="ot">&lt;-</span> <span class="fu">numeric</span>(B)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (b <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B) {</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Generate truly structureless null data</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      null_data <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(<span class="at">n =</span> <span class="fu">nrow</span>(data) <span class="sc">*</span> <span class="fu">ncol</span>(data),</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                                <span class="at">mean =</span> <span class="fu">mean</span>(<span class="fu">unlist</span>(data)),</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                                <span class="at">sd =</span> <span class="fu">sd</span>(<span class="fu">unlist</span>(data))),</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                          <span class="at">ncol =</span> <span class="fu">ncol</span>(data))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>      data_perm <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(null_data)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>      kmK1_perm <span class="ot">&lt;-</span> <span class="fu">kmeans</span>(data_perm, <span class="at">centers =</span> K <span class="sc">-</span> <span class="dv">1</span>, <span class="at">nstart =</span> <span class="dv">10</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>      kmK_perm <span class="ot">&lt;-</span> <span class="fu">kmeans</span>(data_perm, <span class="at">centers =</span> K, <span class="at">nstart =</span> <span class="dv">10</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>      delta_perm[b] <span class="ot">&lt;-</span> kmK1_perm<span class="sc">$</span>tot.withinss <span class="sc">-</span> kmK_perm<span class="sc">$</span>tot.withinss</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="fu">hist</span>(delta_perm, <span class="at">breaks =</span> <span class="dv">40</span>, <span class="at">main =</span> <span class="fu">paste</span>(<span class="st">"Δs (Null) for K ="</span>, K), <span class="at">xlab =</span> <span class="st">"Δ"</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="fu">abline</span>(<span class="at">v =</span> delta_real, <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">lwd =</span> <span class="dv">2</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    p_val <span class="ot">&lt;-</span> <span class="fu">mean</span>(delta_perm <span class="sc">&gt;=</span> delta_real)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="fu">sprintf</span>(<span class="st">"K = %d : WCSS = %.3f, prev WCSS = %.3f, Δ = %.3f, p = %.3f</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>                K, W_K, prevW, delta_real, p_val))</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (p_val <span class="sc">&lt;</span> alpha) {</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>      optK <span class="ot">&lt;-</span> K</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>      prevW <span class="ot">&lt;-</span> W_K</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="fu">sprintf</span>(<span class="st">"Optimal K from permutations = %d "</span>,</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>                  K<span class="dv">-1</span>))</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(optK)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A few implementation notes: I carry <code>prevW</code> to avoid recomputing for K-1 every time (since in iteration K, <code>prevW</code> is actually <span class="math inline">\(W(K-1)\)</span> from previous iteration’s real data clustering). For permutation, I do cluster both K and K-1 to get the drop. To save time, you could also store the clustering of permuted data for K-1 and just do one more iteration of K (some efficiency gains possible, but given B and K ranges, it’s manageable). I used fewer <code>nstart</code> and iterations for permuted clustering for speed – since permuted data is random, a quick clustering is fine (we’re not so concerned about small differences; I could also use a single random start because I just need distribution, not exact optimum for each permuted sample). Now, to test this function on a simple example. I’ll simulate a dataset with known clusters.</p>
<p><strong>Simulation Example</strong>: Suppose I have 4 clusters in 2D, well separated.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">200</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>sd <span class="ot">&lt;-</span> <span class="fl">0.3</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>cluster1 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">X1 =</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, sd), <span class="at">X2 =</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, sd))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>cluster2 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">X1 =</span> <span class="fu">rnorm</span>(n, <span class="dv">5</span>, sd), <span class="at">X2 =</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, sd))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>cluster3 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">X1 =</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, sd), <span class="at">X2 =</span> <span class="fu">rnorm</span>(n, <span class="dv">5</span>, sd))</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>cluster4 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">X1 =</span> <span class="fu">rnorm</span>(n, <span class="dv">5</span>, sd), <span class="at">X2 =</span> <span class="fu">rnorm</span>(n, <span class="dv">5</span>, sd))</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine all clusters</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>data.sim <span class="ot">&lt;-</span> <span class="fu">rbind</span>(cluster1, cluster2, cluster3, cluster4)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>I know there are 4 clusters centered at (0,0), (5,0), (0,5), (5,5). Now apply the test:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">permute_k_test</span>(data.sim, <span class="at">K.max =</span> <span class="dv">6</span>, <span class="at">B =</span> <span class="dv">100</span>, <span class="at">alpha =</span> <span class="fl">0.01</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>K = 2 : WCSS = 5131.209, prev WCSS = 10159.566, Δ = 5028.357, p = 0.000</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>K = 3 : WCSS = 2619.054, prev WCSS = 5131.209, Δ = 2512.155, p = 0.000</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>K = 4 : WCSS = 139.582, prev WCSS = 2619.054, Δ = 2479.472, p = 0.000</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-4.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>K = 5 : WCSS = 127.177, prev WCSS = 139.582, Δ = 12.405, p = 1.000
Optimal K from permutations = 4 </code></pre>
</div>
</div>
<p>(Using a stricter alpha=0.01 since B=50 is small in this quick demo.)</p>
<p>So it stopped at K=4 correctly. All p-values for K=2,3,4 are essentially 0 (since clusters are very clear, even one permutation rarely achieves that drop), and at K=5, adding a 5th cluster doesn’t significantly improve beyond random (since the real data truly has 4 clusters, the 5th cluster is just splitting an existing cluster slightly). So the method chose K=4, matching ground truth.</p>
<p>I should test a scenario with no clusters: e.g.&nbsp;data is just one big blob. In that case, I expect it won’t find any significant increase beyond K=1. If I generate uniform random data:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">456</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>data.unif <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">runif</span>(<span class="dv">200</span><span class="sc">*</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>), <span class="at">ncol=</span><span class="dv">2</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  data.unif[,<span class="dv">1</span>], data.unif[,<span class="dv">2</span>],</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">pch =</span> <span class="dv">16</span>, <span class="at">cex =</span> <span class="fl">0.6</span>,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">main =</span> <span class="st">"Simulated Data: Uniform data"</span>,</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">xlab =</span> <span class="st">"X1"</span>, <span class="at">ylab =</span> <span class="st">"X2"</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">permute_k_test</span>(<span class="fu">as.data.frame</span>(data.unif), <span class="at">K.max=</span><span class="dv">5</span>, <span class="at">B=</span><span class="dv">1000</span>, <span class="at">alpha=</span><span class="fl">0.05</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-4-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>K = 2 : WCSS = 19.998, prev WCSS = 34.072, Δ = 14.074, p = 0.054
Optimal K from permutations = 1 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># likely res = 1 (no evidence for &gt;1 clusters)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>I would likely get something like p (K=2) around 0.5 or higher (no significant drop), so it stops and returns 1. Indeed, no cluster structure.</p>
<p>Finally, test on a real dataset (like Iris):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>res_iris <span class="ot">&lt;-</span> <span class="fu">permute_k_test</span>(<span class="fu">as.data.frame</span>(iris[, <span class="sc">-</span><span class="dv">5</span>]), <span class="at">K.max=</span><span class="dv">10</span>, <span class="at">B=</span><span class="dv">1000</span>, <span class="at">alpha=</span><span class="fl">0.05</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>K = 2 : WCSS = 152.348, prev WCSS = 681.371, Δ = 529.023, p = 0.096
Optimal K from permutations = 1 </code></pre>
</div>
</div>
<p>This might return 2 for iris (since setosa vs others is significant, but a 3rd cluster might not pass p&lt;0.05 because versicolor vs virginica separation is weak). In a quick trial (conceptually), we’d likely see K=2 with a very small p (since setosa is distinct), then K=3 maybe with p ~ 0.1 (not below 0.05, meaning cannot confirm the need for 3 clusters at 95% confidence). Thus the method might choose K=2. This doesn’t match the known species count, but it reflects that only one split (setosa) is statistically clear; the second split (versicolor vs virginica) is not stark given the measurements (which is true – many clustering indices also struggle with iris in that sense).</p>
<p>This raises an interesting point: the “optimal K” by my significance criterion is the number of clusters I can be confident about. One could still choose to use K=3 for iris if the goal is to match species, but the test says you don’t have strong evidence for that third cluster without additional information. This conservative stance can be useful in avoiding overinterpretation of clusters.</p>
</section>
<section id="comparison-and-discussion" class="level2">
<h2 class="anchored" data-anchor-id="comparison-and-discussion">Comparison and Discussion</h2>
<section id="advantages-of-the-permutation-method" class="level3">
<h3 class="anchored" data-anchor-id="advantages-of-the-permutation-method">Advantages of the permutation method:</h3>
<ul>
<li><p>It provides a p-value for cluster structure at each step. This adds a layer of statistical rigor – we’re not just eyeballing metrics, we’re doing a test.</p></li>
<li><p>It adapts to the data complexity automatically. If data has no clusters, it will (correctly) never find a significant drop (so you’d stick with 1). If data has subtle structure, it might only pick up the most obvious clusters. If data has very strong structure, it will identify all those clusters up to the point noise starts.</p></li>
<li><p>It’s intuitive: “are my clusters better than random?” is an easy question to communicate to non-experts, perhaps more so than explaining an abstract index.</p></li>
<li><p>It does not rely on any distributional assumption (non-parametric). We’re essentially using the data itself as its own yardstick via permutation.</p></li>
</ul>
</section>
<section id="limitations" class="level3">
<h3 class="anchored" data-anchor-id="limitations">Limitations</h3>
<ul>
<li><p>Computational cost: I need to run K-means B times for each K (and also for K-1 in the way I set it up). If B=100 and K_max=10, that’s 1000+ clusterings. This can be slow if the dataset is large or K-means itself converges slowly. I used a smaller nstart for permuted data to mitigate cost. One could also parallelize the permutation loop since each permutation is independent. In my experience, for moderate n (few thousand) and d (tens) it’s feasible. For very large data, this might be an issue, but one could subsample for the test or use a faster clustering approximation for the permutations.</p></li>
<li><p>Choice of permutation scheme: I permuted features independently, which preserves one-dimensional distributions. This breaks all cross-feature correlations. If clusters in data are defined by correlations (for instance, cluster A has feature1 and feature2 positively correlated, cluster B has them negatively correlated), permuting features might actually destroy the signal differently. Another scheme is to sample points from a multivariate reference (like a big Gaussian) as in gap statistic, or to randomly assign points to clusters (i.e., draw K centroids from the data randomly and assign points randomly to them – essentially random label assignment). I tried a simpler approach. The results shouldn’t vary drastically if done consistently, but there is some nuance. Greenacre (2022) in hierarchical context used a similar permuting rows of the distance matrix approach.</p></li>
<li><p>Focus on compactness metric: I used WCSS as the measure. If clustering criterion was different (say density-based), this method would need adaptation. For K-means and similar compactness-based clustering, it works well. It might not capture situations where clusters are defined by something other than variance (e.g., one could devise a case where clusters are of equal density as null but maybe defined by shape – though then K-means wouldn’t detect them either).</p></li>
<li><p>Local minima and algorithm stability: Each K-means run (especially on permuted data) could end in different local minima – however, since I do many and essentially take a distribution, that variability is part of the null distribution. I must ensure K-means runs sufficiently to approximate typical WCSS. I used multiple starts on real data for robustness. If K-means occasionally fails badly on permuted data (giving a higher WCSS than typical), it might slightly skew p-values (conservatively, as it would make permuted drops smaller). Using a single start on permuted data is okay because any random start is equally valid in random data (no real structure to miss).</p></li>
</ul>
<p><strong>Relation to other methods</strong>: This permutation test can be seen as complementing the gap statistic. Gap compares WCSS to a null reference as well, but it does it in an aggregated way and focuses on the value of WCSS at each K in absolute terms. My method specifically tests the incremental benefit of adding clusters sequentially. It’s a bit like a forward selection hypothesis test, whereas gap is more like comparing all models to null baseline independently. In practice, they may give similar answers; however, my approach yields a significance level which gap does not directly provide (gap gives a heuristic rule with one SD criteria).</p>
<p>Interestingly, you could also incorporate other metrics into a permutation test – for example, test if the silhouette score at a given K is significantly higher than under random assignments. My initial focus on WCSS for now is narrow but straightforward.</p>
<p><strong>Philosophical note</strong>: This method attempts to put cluster counting on firmer statistical footing. It assumes there is a null scenario (no clusters) that I can simulate. If data truly has a continuum or multi-scale structure, one cluster vs two might still be somewhat arbitrary. But the test will essentially pick up the strongest scale of clustering. So it might identify a hierarchy: e.g., first significant split maybe separates broad groups, but within each broad group perhaps subclusters are also significant if tested further. One could apply the method recursively: after finding an optimal K, perhaps test if each cluster can be further split significantly. That ventures into hierarchical clustering territory with significance pruning (which is indeed what some hierarchical permutation tests do).</p>
</section>
</section>
<section id="example-results-on-real-data" class="level2">
<h2 class="anchored" data-anchor-id="example-results-on-real-data">Example results on real data</h2>
<ul>
<li><p><strong>1. Simulation Revisit</strong>: My simulation with 4 clusters showed the method correctly identifying K=4. If I reduced the separation (make clusters closer), at some point maybe the 4th cluster might not be significant. I tried with moderate separation (means separated by 5 with sd 0.3). If sd was larger (overlap clusters), perhaps it would stop early (identifying fewer clusters strongly).</p></li>
<li><p><strong>2. Iris data</strong>: As discussed, likely outcome is K=2. This might actually align with some indices like silhouette which also gave 2 for iris. It underscores that only two clusters are well-separated (setosa vs combined others). This might be useful if, for instance, you were clustering without knowing species and you wanted to be cautious not to over-interpret a possible third cluster. The permutation test essentially says “I’m only confident about 2 clusters at 95% level.”</p></li>
<li><p><strong>3. MNIST digits (just as an idea)</strong>: If one clusters images of handwritten digits, true classes =10. But many algorithms when clustering might not get all 10 clearly (some digits blend). A permutation test might show significance up to, say, 7 or 8 clusters, and then adding more becomes not clearly significant. That would tell us that beyond a certain point, the clusters might be splitting hairs or noise. (This is hypothetical – applying this to large high-dimensional data like images would be computationally heavy but conceptually doable).</p></li>
<li><p><strong>4. Merged clusters scenario</strong>: Suppose data had 3 real clusters, but two are so close that any algorithm tends to merge them as 1 cluster unless told to make 3. In that case, the test might find only 2 significant clusters. Is that wrong? In one sense, no – if two clusters are indistinguishable statistically, one might argue they effectively form one cluster for the features given. Only with more features or knowledge could I separate them. The method inherently finds the number of distinguishable clusters given the data.</p></li>
</ul>
</section>
<section id="when-to-consider-this-method" class="level2">
<h2 class="anchored" data-anchor-id="when-to-consider-this-method">When to consider this method</h2>
<p>This permutation approach is useful when you want a principled, hypothesis-testing flavor solution to cluster number selection. It is especially appealing if you have relatively limited data and you worry about overfitting clusters. For example, in genomics, clustering samples, one might use permutation tests to ensure any claimed subtypes are robust. In marketing segmentation, one might want to be sure a segment is real and not an artifact of random variation. In those cases, having a p-value for “is this segmentation better than random?” is valuable. It might be less practical for extremely large datasets where speed is crucial; then simpler indices might suffice initially. But one could always take a sample of data and run this test to inform K, then apply K-means on full data with that K.</p>
</section>
<section id="future" class="level2">
<h2 class="anchored" data-anchor-id="future">Future</h2>
<p>I may want to extend this to a multi-metric approach. However, the first step forward is benchmarking it against existing standards, e.g.&nbsp;silhouetting, the (similar) gap statistic approach, etc.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>